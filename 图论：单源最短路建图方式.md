---
title: 
   图论：单源最短路建图方式
tags: 
  [算法,图论]
categories:
    [算法]
---

## [849. Dijkstra求最短路 I](https://www.acwing.com/problem/content/851/)

给定一个n个点m条边的有向图，图中可能存在重边和自环，所有边权均为正值。

请你求出1号点到n号点的最短距离，如果无法从1号点走到n号点，则输出-1。

输入格式
第一行包含整数n和m。

接下来m行每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。

**输出格式**

输出一个整数，表示1号点到n号点的最短距离。

如果路径不存在，则输出-1。

**数据范围**：$1≤n≤500, 1≤m≤10^5$, 图中涉及边长均不超过10000。

**进阶**：$1≤n,m≤1.5×10^5$, 图中涉及边长均不超过10000。

**输入样例：**
```c
3 3
1 2 2
2 3 1
1 3 4
```
**输出样例：**
```c
3
```
### 解法一
Dijkstra适用于非负权图，其核心思路就是将所有的点划分为两部分，一部分是已经确定最短路的点集合$p$，这个集合最开始只有源点。另一部分是未确定最短路的点集合$q$。

1. 首先将刚加入$p$的点的所有出边进行松弛（最开始就是源点$s$）
2. 然后在$q$中找一个离源点$s$最近的，那么这个点的最短路就确定了，因为这个点肯定是经过一个$p$集合中的点进行松弛后的，且图没有负权，所以这个点不可能再通过其他的未确定的点来缩短距离，然后重复步骤一，直到所有点都加入$p$集合

Dijkstra暴力写法，这题题目数据范围比较小$n<500$，所以直接建邻接矩阵然后跑Dijkstra，时间复杂度$O(N^2)$
```java
import java.util.*;
import java.io.*;

class Main {

    public static void main(String... args) throws Exception {
        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream("./input.txt")));
        int INF = 0x3f3f3f3f;
        int[] in = read(br);
        int N = in[0], M = in[1];
        //邻接矩阵
        int[][] w = new int[N][N];
        for (int i = 0; i < N; i++) {
            Arrays.fill(w[i], INF);
        }
        for (int i = 0; i < M; i++) {
            int[] t = read(br); //t[0]->t[1]
            int x = t[0]-1, y = t[1]-1;
            w[x][y] = Math.min(t[2], w[x][y]);
        }
        //dis[i]: 源点s到i的最短距离
        int[] dis = new int[N];
        boolean[] vis = new boolean[N];
        Arrays.fill(dis, INF);
        dis[0] = 0;
        for (int i = 0; i < N; i++) {
            int min = -1;
            //未确定最短路的点中距离s最近的点
            for (int j = 0; j < N; j++) {
                if (!vis[j] && (min==-1 || dis[j] < dis[min])) {
                    min = j;
                }
            }
            //松弛
            vis[min] = true;
            for (int j = 0; j < N; j++) {
                if (!vis[j]) {
                    dis[j] = Math.min(dis[j], dis[min] + w[min][j]);
                }
            }
        }
        out.println(dis[N-1] == INF ? -1 : dis[N-1]);
        out.flush();
    }

    public static int[] read(BufferedReader br) throws Exception {
        return Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
    }
}
```

### 解法二
堆优化的Dijkstra，上面的解法在数据量大的时候显然是不适用的，首先我们不能再使用邻接矩阵了，需要改用邻接表，同时采用**小根堆**来快速的获取**未确定点集**中距离源点最近的点，堆中需要存储节点编号以及最短路，时间复杂度大概$O(m\log n)$，感觉这个复杂度大多数情况都够用了，当然还有一些其它的优化方法，详见[OI-Wiki](https://oi-wiki.org/graph/shortest-path/#dijkstra)
```java
import java.util.*;
import java.io.*;

class Main {

    static class Node {
        int idx, val;
        public Node(int idx, int val) {
            this.idx = idx;
            this.val = val;
        }
    }

    static int idx;
    static int N, M;
    static int[] h, e, ne, w;
    //a->b
    static void add(int a, int b, int c) {
        w[idx] = c; e[idx] = b; 
        ne[idx] = h[a]; h[a] = idx++;
    }

    public static void main(String... args) throws Exception {
        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream("./input.txt")));
        int INF = 0x3f3f3f3f;
        int[] in = read(br);
        N = in[0]; M = in[1];
        h = new int[N+1]; e = new int[M+1]; ne = new int[M+1]; w = new int[M+1];
        Arrays.fill(h, -1);
        for (int i = 0; i < M; i++) {
            int[] t = read(br);
            add(t[0], t[1], t[2]);
        }
        PriorityQueue<Node> pq = new PriorityQueue<>((n1, n2)->n1.val-n2.val);
        int[] dis = new int[N+1];
        //记录已经确定最短路的点集s
        boolean[] vis = new boolean[N+1];
        Arrays.fill(dis, INF);
        dis[1] = 0;
        pq.add(new Node(1, 0));
        while (!pq.isEmpty()) {
            Node node = pq.poll();
            //从未确定最短路的点中找dis最小的（如果弹出来的是已经确定过的就会跳过）
            int i = node.idx, v = node.val;
            if (vis[i]) continue;
            //标记该点已经确定最短路
            vis[i] = true;
            //松弛该点出边
            for (int j = h[i]; j != -1; j = ne[j]) {
                if (v+w[j] < dis[e[j]]) {
                    dis[e[j]] = v+w[j];
                    pq.add(new Node(e[j], v+w[j]));
                }
            }
        }
        out.println(dis[N] == INF ? -1 : dis[N]);
        out.flush();
    }

    public static int[] read(BufferedReader br) throws Exception {
        return Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
    }
}
```