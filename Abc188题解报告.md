---
title: 
   Abc188题解报告
tags: 
  [算法]
categories:
    [算法]
---
> 比赛地址：https://atcoder.jp/contests/abc188
> 第一次打，太菜了只写出了3/6😭
## [A - Three-Point Shot](https://atcoder.jp/contests/abc188/tasks/abc188_a)
判断两个数差值是否大于3，直接判断
## [B - Orthogonality](https://atcoder.jp/contests/abc188/tasks/abc188_b)
求两个数组内积，直接求，注意溢出
## [C - ABC Tournament](https://atcoder.jp/contests/abc188/tasks/abc188_c)
$2^N$players, labeled 
1 through $2^N$ , will compete against each other in a single-elimination programming tournament.
The rating of Player ${i}$ is $A_i$
. Any two players have different ratings, and a match between two players always results in the victory of the player with the higher rating.


The tournament looks like a perfect binary tree.Formally, the tournament will proceed as follows:
- For each integer ${i= 1, 2 , 3 , …,N}$ in this order, the following happens.
  - For each integer ${j(1 \leq j  \leq 2^{N-i}}$, among the players who have never lost, the player with the$(2j-1)$-th smallest label and the player with the $2j$-th smallest label play a match against each other.

Find the label of the player who will take **second place**, that is, lose in the final match.

**Constraints**

- $1 \leq N \leq 16$
- $1 \leq A_i \leq 10^9$
- $A_i$ are pairwise different
- All values in input are integers.

**Sample Input 1**
```c
2
1 4 2 5
```
**Sample Output 1**
```c
2
```
### 解法一
题目的意思就是把输入数组当作一颗完全二叉树的最底层元素，相邻的两个Player进行淘汰（rating低的会被淘汰），求最终battle中败者的索引（第二）
```java
import java.util.*;
import java.io.*;

class Main {
    //2^16 = 65536
    public static void main(String... args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream("./input.txt")));
        int N = Integer.valueOf(br.readLine());
        int[] w = read(br);
        LinkedList<Player> queue = new LinkedList<>();
        for (int i = 0; i < (1<<N); i++) {
            queue.addLast(new Player(i+1, w[i]));
        }
        while (queue.size() > 2) {
            Player p1 = queue.removeFirst();
            Player p2 = queue.removeFirst();
            queue.addLast(p1.rank > p2.rank ? p1 : p2);
        }
        Player p1 = queue.get(0);
        Player p2 = queue.get(1);
        System.out.println(p1.rank > p2.rank ? p2.i : p1.i);
    }

    static class Player{
        int i;
        int rank;
        public Player (int i, int rank) {
            this.rank = rank;
            this.i = i;
        }
    }

    public static int[] read(BufferedReader br) throws Exception {
        return Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
    }
}
```

## [D - Snuke Prime](https://atcoder.jp/contests/abc188/tasks/abc188_d)

Snuke Inc. offers various kinds of services.

A payment plan called Snuke Prime is available.In this plan, by paying $C$
 yen (the currency of Japan) per day, you can use all services offered by the company without additional fees.

You can start your subscription to this plan at the beginning of any day and cancel your subscription at the end of any day.

Takahashi is going to use $N$ of the services offered by the company.

He will use the $i$-th of those services from the beginning of the 
$a_i$-th day until the end of the $b_i$-th day, where today is the first day.
Without a subscription to Snuke Prime, he has to pay $c_i$ yen per day to use the 
$i$-th service.

Find the minimum total amount of money Takahashi has to pay to use the services.

**Constraints**
- $1 \leq N \leq 2 \times 10^5$
- $1 \leq C \leq 10^9$
- $1 \leq a_i \leq b_i \leq 10^9$
- $1 \leq c_i \leq 10^9$
- All values in input are integers.

**Sample Input 1**
```c
2 6
1 2 4
2 2 4
```
**Sample Output 1**
```c
10
```
### 解法一
这题卡了好久，一开始题目的意思就理解了很久，直到结束也没整明白（英语捉急），最后看别人题解的时候才明白啥意思. Otz

这里大概的意思就是说：高桥要使用给出的所有服务，这些服务从$a_i$天开始到$b_i$天结束，每天需要支付$c_i$，同时该公司有另一项政策，就是订阅`Snuke Prime`，当天支付$C$后就可以使用当前出现的所有服务，不用额外的付钱。比如样例一，第一项服务第一天支付4，第二天支付6同时使用第一项服务和第二项服务，总共10，这样消费是最小的。

![](https://i.loli.net/2021/01/11/luhbOUCWjTmzVZ7.png)
要求总体最小的消耗，我们就得知道每天的最小花费是多大，这里题目给的是一个区间$a_i \sim b_i$内所有时间的花费$c[i]$，而这题数据很大，暴力必然是不可行的。解决办法就是构建出差分数组，然后按时间戳排序，计算使用每天出现的各项服务的总花费，和$C$取一个最小值，然后乘以对应的区间的天数，累加起来就是结果
```java
import java.util.*;
import java.io.*;

class Main {

    public static void main(String... args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream("./input.txt")));
        int[] in = read(br);
        int N = in[0];
        int C = in[1];
        HashMap<Integer, Long> diff = new HashMap<>();
        for (int i = 0; i < N; i++) {
            int[] abc = read(br);
            int a = abc[0], b = abc[1], c = abc[2];
            // Java的map确实蛋疼...
            diff.put(a, diff.getOrDefault(a, 0l)+c); diff.put(b+1, diff.getOrDefault(b+1, 0l)-c);
        }
        long res = 0;
        int last = 0; // 上一个时间点
        long sum = 0; // 差分前缀和
        Integer[] keys = diff.keySet().toArray(new Integer[0]);
        // 按照时间排序
        Arrays.sort(keys);
        for (Integer key : keys) {
            long min = Math.min(sum, C);
            res += min * (key-last);
            last = key;
            sum += diff.get(key);
        }
        System.out.println(res);
    }

    public static int[] read(BufferedReader br) throws Exception {
        return Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
    }
}

public class D {
    public static void main(String[] args) throws Exception {
        new Main().main();
    }
}
```

## [E - Peddler](https://atcoder.jp/contests/abc188/tasks/abc188_e)

In Takahashi Kingdom, there are $N$ towns, called Town $1$ through Town $N$.
There are also $M$ roads in the kingdom, called Road $1$ through Road $M$. By traversing Road $i$, you can travel from Town $X_i$ to Town $Y_i$, but not vice versa. Here, it is guaranteed that $X_i < Y_i$.

Gold is actively traded in this kingdom. At Town $i$, you can buy or sell $1$ kilogram of gold for $A_i$ yen (the currency of Japan).

Takahashi, a traveling salesman, plans to buy $1$ kilogram of gold at some town, traverse one or more roads, and sell $1$ kilogram of gold at **another town**.

Find the maximum possible profit (that is, the selling price minus the buying price) in this plan.

**Constraints**
- $2 \leq N \leq 2 \times 10^5$
- $1 \leq M \leq 2 \times 10^5$
- $1 \leq A_i \leq 10^9$
- $1 \leq X_i < Y_i \leq N$
- $(X_i, Y_i) \neq (X_j, Y_j)(i \neq j)$
- All values in input are integers.

**Sample Input 1**
```c
4 3
2 3 1 5
2 4
1 2
1 3
```

**Sample Output 1**
```c
3
```
We can achieve the profit of $3$ yen, as follows:
- At Town $1$, buy one kilogram of gold for $2$ yen.
- Traverse Road $2$ to get to Town $2$.
- Traverse Road $1$ to get to Town $4$.
- At Town $4$, sell one kilogram of gold for $5$ yen.

### 解法一
