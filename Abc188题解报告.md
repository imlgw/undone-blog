---
title: 
   Abc188é¢˜è§£æŠ¥å‘Š
tags: 
  [ç®—æ³•]
categories:
    [ç®—æ³•]
---
> æ¯”èµ›åœ°å€ï¼šhttps://atcoder.jp/contests/abc188
> ç¬¬ä¸€æ¬¡æ‰“ï¼Œå¤ªèœäº†åªå†™å‡ºäº†3/6ğŸ˜­
## [A - Three-Point Shot](https://atcoder.jp/contests/abc188/tasks/abc188_a)
åˆ¤æ–­ä¸¤ä¸ªæ•°å·®å€¼æ˜¯å¦å¤§äº3ï¼Œç›´æ¥åˆ¤æ–­
## [B - Orthogonality](https://atcoder.jp/contests/abc188/tasks/abc188_b)
æ±‚ä¸¤ä¸ªæ•°ç»„å†…ç§¯ï¼Œç›´æ¥æ±‚ï¼Œæ³¨æ„æº¢å‡º
## [C - ABC Tournament](https://atcoder.jp/contests/abc188/tasks/abc188_c)
$2^N$players, labeled 
1 through $2^N$ , will compete against each other in a single-elimination programming tournament.
The rating of Player ${i}$ is $A_i$
. Any two players have different ratings, and a match between two players always results in the victory of the player with the higher rating.


The tournament looks like a perfect binary tree.Formally, the tournament will proceed as follows:
- For each integer ${i= 1, 2 , 3 , â€¦,N}$ in this order, the following happens.
  - For each integer ${j(1 \leq j  \leq 2^{N-i}}$, among the players who have never lost, the player with the$(2j-1)$-th smallest label and the player with the $2j$-th smallest label play a match against each other.

Find the label of the player who will take **second place**, that is, lose in the final match.

**Constraints**

- $1 \leq N \leq 16$
- $1 \leq A_i \leq 10^9$
- $A_i$ are pairwise different
- All values in input are integers.

**Sample Input 1**
```c
2
1 4 2 5
```
**Sample Output 1**
```c
2
```
### è§£æ³•ä¸€
é¢˜ç›®çš„æ„æ€å°±æ˜¯æŠŠè¾“å…¥æ•°ç»„å½“ä½œä¸€é¢—å®Œå…¨äºŒå‰æ ‘çš„æœ€åº•å±‚å…ƒç´ ï¼Œç›¸é‚»çš„ä¸¤ä¸ªPlayerè¿›è¡Œæ·˜æ±°ï¼ˆratingä½çš„ä¼šè¢«æ·˜æ±°ï¼‰ï¼Œæ±‚æœ€ç»ˆbattleä¸­è´¥è€…çš„ç´¢å¼•ï¼ˆç¬¬äºŒï¼‰
```java
import java.util.*;
import java.io.*;

class Main {
    //2^16 = 65536
    public static void main(String... args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream("./input.txt")));
        int N = Integer.valueOf(br.readLine());
        int[] w = read(br);
        LinkedList<Player> queue = new LinkedList<>();
        for (int i = 0; i < (1<<N); i++) {
            queue.addLast(new Player(i+1, w[i]));
        }
        while (queue.size() > 2) {
            Player p1 = queue.removeFirst();
            Player p2 = queue.removeFirst();
            queue.addLast(p1.rank > p2.rank ? p1 : p2);
        }
        Player p1 = queue.get(0);
        Player p2 = queue.get(1);
        System.out.println(p1.rank > p2.rank ? p2.i : p1.i);
    }

    static class Player{
        int i;
        int rank;
        public Player (int i, int rank) {
            this.rank = rank;
            this.i = i;
        }
    }

    public static int[] read(BufferedReader br) throws Exception {
        return Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
    }
}
```

## [D - Snuke Prime](https://atcoder.jp/contests/abc188/tasks/abc188_d)

Snuke Inc. offers various kinds of services.

A payment plan called Snuke Prime is available.In this plan, by paying $C$
 yen (the currency of Japan) per day, you can use all services offered by the company without additional fees.

You can start your subscription to this plan at the beginning of any day and cancel your subscription at the end of any day.

Takahashi is going to use $N$ of the services offered by the company.

He will use the $i$-th of those services from the beginning of the 
$a_i$-th day until the end of the $b_i$-th day, where today is the first day.
Without a subscription to Snuke Prime, he has to pay $c_i$ yen per day to use the 
$i$-th service.

Find the minimum total amount of money Takahashi has to pay to use the services.

**Constraints**
- $1 \leq N \leq 2 \times 10^5$
- $1 \leq C \leq 10^9$
- $1 \leq a_i \leq b_i \leq 10^9$
- $1 \leq c_i \leq 10^9$
- All values in input are integers.

**Sample Input 1**
```c
2 6
1 2 4
2 2 4
```
**Sample Output 1**
```c
10
```
### è§£æ³•ä¸€
è¿™é¢˜å¡äº†å¥½ä¹…ï¼Œä¸€å¼€å§‹é¢˜ç›®çš„æ„æ€å°±ç†è§£äº†å¾ˆä¹…ï¼Œç›´åˆ°ç»“æŸä¹Ÿæ²¡æ•´æ˜ç™½ï¼ˆè‹±è¯­æ‰æ€¥ï¼‰ï¼Œæœ€åçœ‹åˆ«äººé¢˜è§£çš„æ—¶å€™æ‰æ˜ç™½å•¥æ„æ€. Otz

è¿™é‡Œå¤§æ¦‚çš„æ„æ€å°±æ˜¯è¯´ï¼šé«˜æ¡¥è¦ä½¿ç”¨ç»™å‡ºçš„æ‰€æœ‰æœåŠ¡ï¼Œè¿™äº›æœåŠ¡ä»$a_i$å¤©å¼€å§‹åˆ°$b_i$å¤©ç»“æŸï¼Œæ¯å¤©éœ€è¦æ”¯ä»˜$c_i$ï¼ŒåŒæ—¶è¯¥å…¬å¸æœ‰å¦ä¸€é¡¹æ”¿ç­–ï¼Œå°±æ˜¯è®¢é˜…`Snuke Prime`ï¼Œå½“å¤©æ”¯ä»˜$C$åå°±å¯ä»¥ä½¿ç”¨å½“å‰å‡ºç°çš„æ‰€æœ‰æœåŠ¡ï¼Œä¸ç”¨é¢å¤–çš„ä»˜é’±ã€‚æ¯”å¦‚æ ·ä¾‹ä¸€ï¼Œç¬¬ä¸€é¡¹æœåŠ¡ç¬¬ä¸€å¤©æ”¯ä»˜4ï¼Œç¬¬äºŒå¤©æ”¯ä»˜6åŒæ—¶ä½¿ç”¨ç¬¬ä¸€é¡¹æœåŠ¡å’Œç¬¬äºŒé¡¹æœåŠ¡ï¼Œæ€»å…±10ï¼Œè¿™æ ·æ¶ˆè´¹æ˜¯æœ€å°çš„ã€‚

![](https://i.loli.net/2021/01/11/luhbOUCWjTmzVZ7.png)
è¦æ±‚æ€»ä½“æœ€å°çš„æ¶ˆè€—ï¼Œæˆ‘ä»¬å°±å¾—çŸ¥é“æ¯å¤©çš„æœ€å°èŠ±è´¹æ˜¯å¤šå¤§ï¼Œè¿™é‡Œé¢˜ç›®ç»™çš„æ˜¯ä¸€ä¸ªåŒºé—´$a_i \sim b_i$å†…æ‰€æœ‰æ—¶é—´çš„èŠ±è´¹$c[i]$ï¼Œè€Œè¿™é¢˜æ•°æ®å¾ˆå¤§ï¼Œæš´åŠ›å¿…ç„¶æ˜¯ä¸å¯è¡Œçš„ã€‚è§£å†³åŠæ³•å°±æ˜¯æ„å»ºå‡ºå·®åˆ†æ•°ç»„ï¼Œç„¶åæŒ‰æ—¶é—´æˆ³æ’åºï¼Œè®¡ç®—ä½¿ç”¨æ¯å¤©å‡ºç°çš„å„é¡¹æœåŠ¡çš„æ€»èŠ±è´¹ï¼Œå’Œ$C$å–ä¸€ä¸ªæœ€å°å€¼ï¼Œç„¶åä¹˜ä»¥å¯¹åº”çš„åŒºé—´çš„å¤©æ•°ï¼Œç´¯åŠ èµ·æ¥å°±æ˜¯ç»“æœ
```java
import java.util.*;
import java.io.*;

class Main {

    public static void main(String... args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream("./input.txt")));
        int[] in = read(br);
        int N = in[0];
        int C = in[1];
        HashMap<Integer, Long> diff = new HashMap<>();
        for (int i = 0; i < N; i++) {
            int[] abc = read(br);
            int a = abc[0], b = abc[1], c = abc[2];
            // Javaçš„mapç¡®å®è›‹ç–¼...
            diff.put(a, diff.getOrDefault(a, 0l)+c); diff.put(b+1, diff.getOrDefault(b+1, 0l)-c);
        }
        long res = 0;
        int last = 0; // ä¸Šä¸€ä¸ªæ—¶é—´ç‚¹
        long sum = 0; // å·®åˆ†å‰ç¼€å’Œ
        Integer[] keys = diff.keySet().toArray(new Integer[0]);
        // æŒ‰ç…§æ—¶é—´æ’åº
        Arrays.sort(keys);
        for (Integer key : keys) {
            long min = Math.min(sum, C);
            res += min * (key-last);
            last = key;
            sum += diff.get(key);
        }
        System.out.println(res);
    }

    public static int[] read(BufferedReader br) throws Exception {
        return Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
    }
}

public class D {
    public static void main(String[] args) throws Exception {
        new Main().main();
    }
}
```

## [E - Peddler](https://atcoder.jp/contests/abc188/tasks/abc188_e)

In Takahashi Kingdom, there are $N$ towns, called Town $1$ through Town $N$.
There are also $M$ roads in the kingdom, called Road $1$ through Road $M$. By traversing Road $i$, you can travel from Town $X_i$ to Town $Y_i$, but not vice versa. Here, it is guaranteed that $X_i < Y_i$.

Gold is actively traded in this kingdom. At Town $i$, you can buy or sell $1$ kilogram of gold for $A_i$ yen (the currency of Japan).

Takahashi, a traveling salesman, plans to buy $1$ kilogram of gold at some town, traverse one or more roads, and sell $1$ kilogram of gold at **another town**.

Find the maximum possible profit (that is, the selling price minus the buying price) in this plan.

**Constraints**
- $2 \leq N \leq 2 \times 10^5$
- $1 \leq M \leq 2 \times 10^5$
- $1 \leq A_i \leq 10^9$
- $1 \leq X_i < Y_i \leq N$
- $(X_i, Y_i) \neq (X_j, Y_j)(i \neq j)$
- All values in input are integers.

**Sample Input 1**
```c
4 3
2 3 1 5
2 4
1 2
1 3
```

**Sample Output 1**
```c
3
```
We can achieve the profit of $3$ yen, as follows:
- At Town $1$, buy one kilogram of gold for $2$ yen.
- Traverse Road $2$ to get to Town $2$.
- Traverse Road $1$ to get to Town $4$.
- At Town $4$, sell one kilogram of gold for $5$ yen.

### è§£æ³•ä¸€
