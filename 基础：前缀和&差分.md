---
title: 
   基础：前缀和&差分
tags: 
  [前缀和,差分,算法]
categories:
    [算法]
---

## [796. 子矩阵的和（模板题）](https://www.acwing.com/problem/content/description/798/)

输入一个$n$行$m$列的整数矩阵，再输入$q$个询问，每个询问包含四个整数 $x_1,y_1,x_2,y_2$，表示一个子矩阵的左上角坐标和右下角坐标。

对于每个询问输出子矩阵中所有数的和。

**输入格式**

第一行包含三个整数$n，m，q$。

接下来$n$行，每行包含$m$个整数，表示整数矩阵。

接下来$q$行，每行包含四个整数$x_1,y_1,x_2,y_2$，表示一组询问。

**输出格式**

共$q$行，每行输出一个询问的结果。

**数据范围**
- $1≤n,m≤1000$
- $1≤q≤200000$
- $1≤x1≤x_2≤n$
- $1≤y1≤y_2≤m$
- $−1000≤v≤1000$

**输入样例：**
```c
3 4 3
1 7 2 4
3 6 2 8
2 1 2 3
1 1 2 2
2 1 3 4
1 3 3 4
```
**输出样例：**
```c
17
27
21
```
### 解法一
二维前缀和模板，一维的模板比较简单就不多写了
```java
import java.util.*;
import java.io.*;

class Main {

    public static void main(String... args) throws Exception {
        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream("./input.txt")));
        int[] in = read(br);
        int N = in[0], M = in[1], Q = in[2];
        int[][] sum = new int[N+1][M+1];
        for (int i = 1; i <= N; i++) {
            int[] t = read(br);
            for (int j = 1; j <= M; j++) {
                sum[i][j] = t[j-1] + sum[i][j-1] + sum[i-1][j] - sum[i-1][j-1];
            }
        }
        for (int i = 0; i < Q; i++) {
            int[] q = read(br);
            int x1 = q[0], y1 = q[1];
            int x2 = q[2], y2 = q[3];
            out.println(sum[x2][y2]-(sum[x1-1][y2]+sum[x2][y1-1])+sum[x1-1][y1-1]);
        }
        out.flush();
    }

    public static int[] read(BufferedReader br) throws Exception {
        return Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
    }
}
```

## [99. 激光炸弹](https://www.acwing.com/problem/content/description/101/)

地图上有$N$个目标，用整数$X_i,Y_i$表示目标在地图上的位置，每个目标都有一个价值$W_i$。

**注意**：不同目标可能在同一位置。

现在有一种新型的激光炸弹，可以摧毁一个包含$R×R$个位置的正方形内的所有目标。

激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆炸范围，即那个正方形的边必须和$x，y$轴平行。

求一颗炸弹最多能炸掉地图上总价值为多少的目标。

**输入格式**

第一行输入正整数$N$和$R$，分别代表地图上的目标数目和正方形的边长，数据用空格隔开。

接下来$N$行，每行输入一组数据，每组数据包括三个整数$X_i,Y_i,W_i$，分别代表目标的$x$坐标，$y$坐标和价值，数据用空格隔开。

**输出格式**

输出一个正整数，代表一颗炸弹最多能炸掉地图上目标的总价值数目。

**数据范围**
- $0≤R≤10^9$
- $0<N≤10000$
- $0≤X_i,Y_i≤5000$
- $0≤W_i≤1000$

**输入样例：**
```c
2 1
0 0 1
1 1 1
```
**输出样例：**
```c
1
```
### 解法一
其实也是个模板题...注意多个目标会在同一个点
```java
import java.util.*;
import java.io.*;

class Main {

    public static void main(String... args) throws Exception {
        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream("./input.txt")));
        int[] in = read(br);
        int MAX = 5010;
        int N = in[0], R = in[1];
        int[][] w = new int[MAX][MAX];
        for (int i = 0; i < N; i++) {
            int[] t = read(br);
            w[t[0]][t[1]] += t[2];
        }
        int[][] sum = new int[MAX][MAX];
        for (int i = 1; i < MAX; i++) {
            for (int j = 1; j < MAX; j++) {
                sum[i][j] = w[i-1][j-1] + sum[i][j-1] + sum[i-1][j] - sum[i-1][j-1];
            }
        }
        int res = 0;
        for (int i = 1; i < MAX; i++) {
            if (i+R-1 >= MAX) break;
            for (int j = 1; j < MAX; j++) {
                if (j+R-1 >= MAX) break;
                int i2 = i+R-1, j2 = j+R-1;
                res = Math.max(res, sum[i2][j2]-sum[i-1][j2]-sum[i2][j-1]+sum[i-1][j-1]);
            }
        }
        out.println(res);
        out.flush();
    }

    public static int[] read(BufferedReader br) throws Exception {
        return Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
    }
}
```

## [1292. 元素和小于等于阈值的正方形的最大边长](https://leetcode-cn.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/) 

给你一个大小为 `m x n` 的矩阵 `mat` 和一个整数阈值 `threshold`。

请你返回元素总和小于或等于阈值的正方形区域的最大边长；如果没有这样的正方形区域，则返回$0$。


**示例 1：**

![Y2wPne.png](https://s1.ax1x.com/2020/05/17/Y2wPne.png)

```c
输入：mat = [[1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2]], threshold = 4
输出：2
解释：总和小于 4 的正方形的最大边长为 2，如图所示。
```

**示例 2：**

```c
输入：mat = [[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2]], threshold = 1
输出：0
```

**示例 3：**

```c
输入：mat = [[1,1,1,1],[1,0,0,0],[1,0,0,0],[1,0,0,0]], threshold = 6
输出：3
```

**示例 4：**

```java
输入：mat = [[18,70],[61,1],[25,85],[14,40],[11,96],[97,96],[63,45]], threshold = 40184
输出：2
```

**提示：**

- $1 \leq m, n \leq 300$
- $m = mat.length$
- $n = mat[i].length$
- $0 \leq mat[i][j] \leq 10000$
- $0 \leq threshold \leq 10^5$

### 解法一
> 这里直接将之前的[题解](https://imlgw.top/2019/12/06/leetcode-er-fen-cha-zhao/#1292-%E5%85%83%E7%B4%A0%E5%92%8C%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E%E9%98%88%E5%80%BC%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%9A%84%E6%9C%80%E5%A4%A7%E8%BE%B9%E9%95%BF)搬过来了，相对来说这题就没那么模板了，结合了二分，还是挺好的

首先看到这道题就意识到了这是个二分答案的题，直接二分边长就行了，左端点$1$，右端点$\min(m,n)$，某个边长$x$满足的时候，大于$x$的都满足，某个$x$不满足的时候，小于$x$的都不满足，解空间具有单调性

所以关键问题就是`check`怎么写，如果直接暴力枚举所有矩形然后计算时间复杂度会很恐怖，这个时候就可以引入**二维前缀和**，在$O(1)$的时间下求出子矩阵的和

```java
class Solution {

    int[][] sum;

    public int maxSideLength(int[][] mat, int threshold) {
        int m = mat.length;
        int n = mat[0].length;
        int left = 1, right = Math.min(m, n);
        sum = new int[m+1][n+1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = mat[i-1][j-1] + sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1];
            }
        }
        int res = 0;
        while(left <= right){
            int mid = left + (right-left)/2;
            if(check(mat, mid, threshold)){
                res = mid;
                left = mid+1;
            }else{
                right = mid-1;
            }
        }
        return res;
    }
    
    public boolean check(int[][] mat, int side, int threshold){
        //枚举所有的左端点
        for (int i = 1; i+side-1 <= mat.length; i++) {
            for (int j = 1; j+side-1 <= mat[0].length; j++) {
                int ri = i+side-1, rj = j+side-1;
                if(sum[ri][rj]-sum[i-1][rj]-sum[ri][j-1]+sum[i-1][j-1] <= threshold){
                    return true;
                }
            }
        }
        return false;
    }
}
```

## [798. 差分矩阵（模板题）](https://www.acwing.com/problem/content/description/800/)
输入一个$n$行$m$列的整数矩阵，再输入$q$个操作，每个操作包含五个整数 $x_1,y_1,x_2,y_2,c$，其中$(x_1,y_1)$和$(x_2,y_2)$表示一个子矩阵的左上角坐标和右下角坐标。

每个操作都要将选中的子矩阵中的每个元素的值加上$c$。

请你将进行完所有操作后的矩阵输出。

**输入格式**

第一行包含整数$n,m,q$。

接下来$n$行，每行包含$m$个整数，表示整数矩阵。

接下来$q$行，每行包含$5$个整数$x_1,y_1,x_2,y_2,c$，表示一个操作。

**输出格式**

共$n$行，每行$m$个整数，表示所有操作进行完毕后的最终矩阵。

**数据范围**
- $1≤n,m≤1000$
- $1≤q≤100000$
- $1≤x1≤x2≤n$
- $1≤y1≤y2≤m$
- $−1000≤c≤1000$
- $−1000≤v≤1000$

**输入样例：**
```c
3 4 3
1 2 2 1
3 2 2 1
1 1 1 1
1 1 2 2 1
1 3 2 3 2
3 1 3 4 1
```
**输出样例：**
```c
2 3 4 1
4 3 4 1
2 2 2 2
```
### 解法一
二维差分模板题，一维的模板也比较简单就不多写了，二维的需要多说几句

和前缀和相反，矩阵中某个元素$matrix[i][j]$的值是差分数组$(0,0)$到$(i,j)$的二维前缀和，所以当我们给某个点$(i,j)$的差分值加$c$的时候，会使以该点为左上角，到整个矩阵的右下角$(n,m)$的矩阵区域**元素值**增加$c$
，如下图当给$(x_1, y_1)$的差分值增加$c$的时候，会使得整个蓝色框区域的矩阵元素值都增加$c$
![mark](https://static.imlgw.top/blog/20210404/CekHvl3vfuR8.png)
但是这里我们只希望子矩阵$(x_1,y_1),(x_2,y_2)$的值增加，所以我们需要将其它区域的值减回去。所以我们给$(x_1,y_2+1)$以及$(x_2+1,y_1)$的差分值减$c$，注意这两块有一个重合区域$(x_2+1,y_2+1)$多减了一次，我们将其加回来就行了
```java
import java.util.*;
import java.io.*;

class Main {

    static int[][] diff;
    static int n, m, q;
    public static void main(String... args) throws Exception {
        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream("./input.txt")));
        int[] in = read(br);
        n = in[0]; m = in[1]; q = in[2];
        diff = new int[n+2][m+2];
        for (int i = 1; i <= n; i++) {
            int[] t = read(br);
            for (int j = 1; j <= m; j++) {
                incr(i, j, i, j, t[j-1]);
            }
        }
        for (int i = 0; i < q; i++) {
            int[] q = read(br);
            incr(q[0], q[1], q[2], q[3], q[4]);
        }
        int[][] matrix = new int[n+2][m+2];
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                matrix[i][j] = diff[i][j] + matrix[i-1][j] + matrix[i][j-1] - matrix[i-1][j-1];
                out.print(matrix[i][j] + " ");
            }
            out.println();
        }
        out.flush();
    }

    public static void incr(int x1, int y1, int x2, int y2, int c) {
        diff[x1][y1] += c;
        diff[x1][y2+1] -= c;
        diff[x2+1][y1] -= c;
        diff[x2+1][y2+1] += c;
    }

    public static int[] read(BufferedReader br) throws Exception {
        return Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
    }
}
```

