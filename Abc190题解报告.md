---
title: 
   AtCoder Beginner Contest 190
tags: 
  [算法]
categories:
    [算法]
---

## [E - Magical Ornament](https://atcoder.jp/contests/abc190/tasks/abc190_e)

There are $N$ kinds of magical gems, numbered $1, 2, \ldots, N$, distributed in the AtCoder Kingdom.

Takahashi is trying to make an ornament by arranging gems in a row.

For some pairs of gems, we can put the two gems next to each other; for other pairs, we cannot. We have $M$ pairs for which the two gems can be adjacent: (Gem $A_1$, Gem $B_1$), (Gem $A_2$, Gem $B_2$), $\ldots$, (Gem $A_M$, Gem $B_M$). For the other pairs, the two gems cannot be adjacent. (Order does not matter in these pairs.)

Determine whether it is possible to form a sequence of gems that has one or more gems of each of the kinds $C_1, C_2, \dots, C_K$. If the answer is yes, find the minimum number of stones needed to form such a sequence.

**Constraints**

- All values in input are integers.
- $1 ≤ N ≤ 10^5$
- $0 ≤ M ≤ 10^5$
- $1 ≤ A_i < B_i ≤ N$
- If$i ≠ j, (A_i, B_i) ≠ (A_j, B_j)$.
- $1 ≤ K ≤ 17$
- $1 ≤ C_1 < C_2 < \dots < C_K ≤ N$

**Sample Input 1**
```c
4 3
1 4
2 4
3 4
3
1 2 3
```
**Sample Output 1**
```c
5
```

### 解法一
bfs+状态压缩，因为$K$很小，所以我们可以将给定的输入转换成一个双向图，然后将关键点之间的最短路径求出来，这里直接BFS就行了，时间复杂度$O(K*(N+M))$，得到一个$dist[i][j]$，表示第$i$-th关键点和第$j$-th个关键点的最短路径

然后再进行状态压缩，设置状态为：$dp[mask][last]$，选取$mask$代表的 **关键宝石**，并且以$last$宝石结尾的最短序列长度（显然$last$一定是关键宝石）
- 入口：$dp[1 \ll  i][i] = 1$，只选取一个关键宝石，序列长度为1
- 转移：$dp[mask|(1\ll i)][i] = \min(dp[mask][j] + dist[i][j])$
- 出口：$\min_i(dp[(1 \ll k)-1][i])$，选取到所有的关键石头，并且以某个关键石头结尾的最小值

代码实现如下（注意下标统一，给的输入都是从1开始的，需要转换，一开始转换掉了一个，找了半天的bug）：
```java
import java.util.*;
import java.io.*;

class Main {

    public static void main(String... args) throws Exception {
        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream("./input.txt")));
        int[] in = read(br);
        int N = in[0], M = in[1];
        int INF = 0x3f3f3f3f;
        List<Integer>[] adj = new ArrayList[N];
        for (int i = 0; i < M; i++) {
            int[] t = read(br);
            int x = t[0]-1, y = t[1]-1;
            if (adj[x] == null) {
                adj[x] = new ArrayList<>();
            }
            if (adj[y] == null) {
                adj[y] = new ArrayList<>();
            }
            adj[x].add(y); adj[y].add(x);
        }
        int K = read(br)[0];
        int[] C = read(br);
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < K; i++) map.put(--C[i], i);
        //K个关键点之间的最短距离
        int[][] dis = new int[K][K];
        Queue<int[]> queue = new LinkedList<>();
        for (int i = 0; i < K; i++) {
            Arrays.fill(dis[i], INF);
            queue.clear();
            queue.add(new int[]{C[i], 0});
            boolean[] vis = new boolean[N];
            while (!queue.isEmpty()) {
                int[] cur = queue.poll();
                if (map.containsKey(cur[0])) {
                    dis[i][map.get(cur[0])] = cur[1];
                }
                if (adj[cur[0]] == null) continue;
                for (Integer next : adj[cur[0]]) {
                    if (vis[next]) continue;
                    queue.add(new int[]{next, cur[1]+1});
                    vis[next] = true;
                }
            }
        }
        int[][] dp = new int[1<<K][K];
        for (int i = 0; i < (1<<K); i++) {
            Arrays.fill(dp[i], INF);
        } 
        for (int i = 0; i < K; i++) {
            dp[1<<i][i] = 1;
        }
        //枚举所有状态递推
        for (int mask = 0; mask < (1<<K); mask++) {
            for (int i = 0; i < K; i++) {
                //C[i]被选取，C[j]未被选取（判断去掉也可AC）
                if ((mask&(1<<i))==0) continue;
                for (int j = 0; j < K; j++) {
                    if ((mask&(1<<j))==1 || dis[i][j] == INF || dp[mask][i] == INF) continue;
                    dp[mask|(1<<j)][j] = Math.min(dp[mask|(1<<j)][j], dp[mask][i] + dis[i][j]);
                }
            }
        }
        int res = INF;
        for (int i = 0; i < K; i++) {
            res = Math.min(res, dp[(1<<K)-1][i]);
        }
        if (res == INF) out.println(-1);  
        else out.println(res);
        out.flush();
    }

    public static int[] read(BufferedReader br) throws Exception {
        return Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
    }
}
```
## [F - Shift and Inversions](https://atcoder.jp/contests/abc190/tasks/abc190_f)
Given is a sequence $A = [a_0, a_1, a_2, \dots, a_{N-1}]$ that is a permutation of $0, 1, 2, \dots, N - 1$.

For each $k = 0, 1, 2, \dots, N - 1$, find the inversion number of the sequence $B = [b_0, b_1, b_2, \dots, b_{N-1}]$ defined as $b_i = a_{i+k \bmod N}$.

**Constraints**
- All values in input are integers.
- $2≤N≤3×10^5$
- $a_0,a_1,a_2,…,a_{N−1}$ is a permutation of $0,1,2,…,N−1$.

**Sample Input 1**
```c
4
0 1 2 3
```
**Sample Output 1**
```c
0
3
4
3
```
We have $A = [0, 1, 2, 3]$.
- For $k = 0$, the inversion number of $B = [0, 1, 2, 3]$ is $0$.
- For $k = 1$, the inversion number of $B = [1, 2, 3, 0]$ is $3$.
- For $k = 2$, the inversion number of $B = [2, 3, 0, 1]$ is $4$.
- For $k = 3$, the inversion number of $B = [3, 0, 1, 2]$ is $3$.

### 解法一
首先$B_{k=i}$序列实际上就是$A$数组将开头的$i$个元素移动到后面得到的序列。同时题目说了给定的$A$序列是$0，1，2 \ldots N-1$的一个排列，所以我们把某个元素从开头移动到结尾的逆序对变化是可以直接计算出来的

![](https://i.loli.net/2021/02/03/TFsGkEvZjxqiVHm.png)
所以我们只需要求出初始$A$数组的逆序对个数然后按照上面的式子递推就行了，这里我采用树状数组的方法求逆序对，也可以用归并排序的方式
```java
import java.util.*;
import java.io.*;

class Main {

    static int[] tree;

    public static int lowbit(int x) {
        return x & -x;
    }

    //q[1001] = t[1001] + t[1000]
    public static int query(int i) {
        int res = 0;
        while (i > 0) {
            res += tree[i];
            i -= lowbit(i);
        }
        return res;
    }

    public static void add(int i, int val) {
        while (i < tree.length) {
            tree[i] += val;
            i += lowbit(i);
        }
    }

    public static void main(String... args) throws Exception {
        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream("./input.txt")));
        int N = read(br)[0];
        int[] A = read(br);
        tree = new int[N+1];
        //离散化（这题不用离散化，这里属于吃饱了撑了）
        int[][] temp = new int[N][2];
        for (int i = 0; i < N; i++) temp[i] = new int[]{A[i], i};
        Arrays.sort(temp, (t1, t2)->t1[0]-t2[0]);
        int[] rank = new int[N];
        for (int i = 0; i < N; i++) {
            rank[temp[i][1]] = i+1;
        }
        long res = 0;
        //树状数组或者归并都可
        for (int i = N-1; i >= 0; i--) {
            add(rank[i]+1, 1);
            res += query(rank[i]);
        }
        out.println(res);
        //-k+(N-1-k) = N-1-2*k
        for (int i = 0; i < N-1; i++) {
            res += N-1-2*A[i];
            out.println(res);
        }
        out.flush();
    }

    public static int[] read(BufferedReader br) throws Exception {
        return Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
    }
}
```
> 一开始写了个假的算法结果AC了，主要是离散化写错了（这题本来也不用离散化，写离散化属于我吃饱了撑的，完了还写了个错的，还好，给自己提前暴雷了），幸好我尝试去写了其他的解法，不然这个错误就被混过去了 [错误代码Gist](https://gist.github.com/imlgw/0d89d211ebd0f032c109daed8566db5a)
### 解法二
进一步的解法，序列的值是完全随机的的做法，这个时候归并就不太行了，而对于树状数组只需要稍微稍微改动一下就行了。
```java
class Main {

    static int[] tree;

    public static int lowbit(int x) {
        return x & -x;
    }

    //q[1001] = t[1001] + t[1000]
    public static int query(int i) {
        int res = 0;
        while (i > 0) {
            res += tree[i];
            i -= lowbit(i);
        }
        return res;
    }

    public static void add(int i, int val) {
        while (i < tree.length) {
            tree[i] += val;
            i += lowbit(i);
        }
    }

    public static void main(String... args) throws Exception {
        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream("./input.txt")));
        int N = read(br)[0];
        int[] A = read(br);
        tree = new int[N+1];
        //离散化（这题不用离散化，为了更加通用）
        int[][] temp = new int[N][2];
        for (int i = 0; i < N; i++) temp[i] = new int[]{A[i], i};
        Arrays.sort(temp, (t1, t2)->t1[0]-t2[0]);
        int[] rank = new int[N];
        for (int i = 0; i < N; i++) {
            rank[temp[i][1]] = i+1;
        }
        long res = 0;
        //树状数组或者归并都可
        for (int i = N-1; i >= 0; i--) {
            add(rank[i], 1);
            res += query(rank[i]-1);
        }
        out.println(res);
        //改动的地方
        for (int i = 0; i < N-1; i++) {
            res -= query(rank[i]-1);
            res += query(N) - query(rank[i]);
            out.println(res);
        }
        out.flush();
    }

    public static int[] read(BufferedReader br) throws Exception {
        return Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
    }
}
```