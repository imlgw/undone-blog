---
title: 
   图论：单源最短路的建图方式
tags: 
  [算法,图论]
categories:
    [算法]
---
> 相关文章：[图论：常见的最短路算法模板](https://imlgw.top/2021/03/17/tu-lun-chang-jian-zui-duan-lu-suan-fa-mo-ban/)
## [1129. 热浪](https://www.acwing.com/problem/content/description/1131/)

德克萨斯纯朴的民众们这个夏天正在遭受巨大的热浪！！！

他们的德克萨斯长角牛吃起来不错，可是它们并不是很擅长生产富含奶油的乳制品，农夫John此时身先士卒地承担起向德克萨斯运送大量的营养冰凉的牛奶的重任，以减轻德克萨斯人忍受酷暑的痛苦。

John已经研究过可以把牛奶从威斯康星运送到德克萨斯州的路线。这些路线包括起始点和终点一共有$T$个城镇，为了方便标号为$1$到$T$。除了起点和终点外的每个城镇都由**双向道路**连向至少两个其它的城镇。每条道路有一个通过费用（包括油费，过路费等等）。

给定一个地图，包含$C$条直接连接2个城镇的道路。每条道路由道路的起点$R_s$，终点$R_e$和花费$C_i$组成。求从起始的城镇$T_s$到终点的城镇$T_e$最小的总费用。

**输入格式**

第一行: 4个由空格隔开的整数: $T,C,T_s,T_e$;

第 2 到第 $C+1$ 行: 第 $i+1$ 行描述第$i$条道路，包含3个由空格隔开的整数: $R_s,R_e,C_i$。

**输出格式**

一个单独的整数表示从$T_s$到$T_e$的最小总费用。数据保证至少存在一条道路。

**数据范围**
- $1≤T≤2500$
- $1≤C≤6200$
- $1≤Ts,Te,Rs,Re≤T$
- $1≤Ci≤1000$

**输入样例：**
```c
7 11 5 4
2 4 2
1 4 3
7 2 2
3 4 3
5 7 5
7 3 3
6 1 1
6 3 4
2 4 3
5 6 3
7 2 1
```
**输出样例：**
```c
7
```

### 解法一
很裸的题，正权图，数据范围不是很大，直接使用堆优化的`Dijkstra`
<details>

```java
import java.util.*;
import java.io.*;

class Main {

    public static void main(String... args) throws Exception {
        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream("./input.txt")));
        int[] in = read(br);
        int INF = 0x3f3f3f3f;
        int T = in[0], C = in[1], Ts = in[2], Te = in[3];
        int[][] w = new int[T+1][T+1];
        for (int i = 1; i <= T; i++) {
            Arrays.fill(w[i], INF);
        }
        for (int i = 0; i < C; i++) {
            int[] t = read(br);
            int x = t[0], y = t[1];
            w[x][y] = Math.min(w[x][y], t[2]);
            w[y][x] = Math.min(w[y][x], t[2]);
        }
        int[] dis = new int[T+1];
        Arrays.fill(dis, INF);
        dis[Ts] = 0;
        boolean[] vis = new boolean[T+1];
        PriorityQueue<Integer> queue = new PriorityQueue<>((a, b)->dis[a]-dis[b]);
        queue.add(Ts);
        while (!queue.isEmpty()) {
            int i = queue.poll();
            if (vis[i]) continue;
            vis[i] = true;
            for (int j = 1; j <= T; j++) {
                if (w[i][j] == INF) continue;
                if (dis[j] > dis[i] + w[i][j]) {
                    dis[j] = dis[i] + w[i][j];
                    queue.add(j);
                }
            }
        }
        out.println(dis[Te]);
        out.flush();
    }

    public static int[] read(BufferedReader br) throws Exception {
        return Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
    }
}
```
</details>

## [1128. 信使](https://www.acwing.com/problem/content/1130/)

战争时期，前线有$n$个哨所，每个哨所可能会与其他若干个哨所之间有通信联系。

信使负责在哨所之间传递信息，当然，这是要花费一定时间的（以天为单位）。
**指挥部设在第一个哨所**，当指挥部下达一个命令后，指挥部就派出若干个信使向与指挥部相连的哨所送信，当一个哨所接到信后，这个哨所内的信使们也以同样的方式向其他哨所送信。信在一个哨所内停留的时间可以忽略不计，直至所有 n 个哨所全部接到命令后，送信才算成功。

因为准备充足，每个哨所内都安排了足够的信使（如果一个哨所与其他 k 个哨所有通信联系的话，这个哨所内至少会配备 k 个信使）。

现在总指挥请你编一个程序，计算出完成整个送信过程最短需要多少时间。

**输入格式**

第$1$行有两个整数$n$和$m$，中间用$1$个空格隔开，分别表示有$n$个哨所和$m$条通信线路。

第$2$至$m+1$行：每行三个整数$i,j,k$，中间用$1$个空格隔开，表示第$i$个和第$j$个哨所之间存在 双向 通信线路，且这条线路要花费$k$天。

**输出格式**

一个整数，表示完成整个送信过程的最短时间，如果不是所有的哨所都能收到信，就输出-1。

**数据范围**
- $1≤n≤100$
- $1≤m≤200$
- $1≤k≤1000$

**输入样例：**
```c
4 4
1 2 4
2 3 7
2 4 1
3 4 6
```
**输出样例：**
```c
11
```

### 解法一
求至少需要多长时间其实就是求**最长的最短路**，数据范围很小，可以直接Floyd，我这里写了个SPFA
<details>

```java
import java.util.*;
import java.io.*;

class Main {

    public static void main(String... args) throws Exception {
        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int[] in = read(br);
        int INF = 0x3f3f3f3f;
        int N = in[0], M = in[1];
        int[][] w = new int[N+1][N+1];
        for (int i = 1; i <= N; i++) {
            Arrays.fill(w[i], INF);
        }
        for (int i = 0; i < M; i++) {
            int[] t = read(br);
            int x = t[0], y = t[1];
            w[x][y] = Math.min(w[x][y], t[2]);
            w[y][x] = Math.min(w[y][x], t[2]);
        }
        int[] dis = new int[N+1];
        boolean[] vis = new boolean[N+1];
        Arrays.fill(dis, INF);
        dis[1] = 0;
        Queue<Integer> queue = new LinkedList<>();
        queue.add(1); vis[1] = true;
        while (!queue.isEmpty()) {
            int i = queue.poll();
            vis[i] = false;
            for (int j = 1; j <= N; j++) {
                if (w[i][j]==INF) continue; //其实dis[i]不会为INF
                if (dis[j] > dis[i] + w[i][j]) {
                    dis[j] = dis[i] + w[i][j];
                    if (!vis[j]) {
                        queue.add(j);
                        vis[j] = true;
                    }
                }
            }
        }
        int res = 0;
        for (int i = 1; i <= N; i++) {
            res = Math.max(res, dis[i]);
        }
        out.println(res==INF ? -1 : res);
        out.flush();
    }

    public static int[] read(BufferedReader br) throws Exception {
        return Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
    }
}
```
</details>

## [1127. 香甜的黄油](https://www.acwing.com/problem/content/description/1129/)

农夫John发现了做出全威斯康辛州最甜的黄油的方法：糖。

把糖放在一片牧场上，他知道$N$只奶牛会过来舔它，这样就能做出能卖好价钱的超甜黄油。当然，他将付出额外的费用在奶牛上。

农夫John很狡猾，就像以前的巴甫洛夫，他知道他可以训练这些奶牛，让它们在听到铃声时去一个特定的牧场。

他打算将糖放在那里然后下午发出铃声，以至他可以在晚上挤奶。

农夫John知道每只奶牛都在各自喜欢的牧场（一个牧场不一定只有一头牛）。

给出各头牛在的牧场和牧场间的路线，找出使所有牛到达的路程和最短的牧场（他将把糖放在那）。

数据保证至少存在一个牧场和所有牛所在的牧场连通。

**输入格式**

第一行: 三个数：奶牛数$N$，牧场数$P$，牧场间道路数$C$。

第二行到第$N+1$行: $1$到$N$头奶牛所在的牧场号。

第$N+2$行到第$N+C+1$行：每行有三个数：相连的牧场$A，B$，两牧场间距 $D$，当然，连接是双向的。

**输出格式**

共一行，输出奶牛必须行走的最小的距离和。

**数据范围**
- $1≤N≤500$
- $2≤P≤800$
- $1≤C≤1450$
- $1≤D≤255$

**输入样例：**
```c
3 4 5
2
3
4
1 2 1
1 3 5
2 3 7
2 4 3
3 4 5
```
**输出样例：**
```c
8
```

### 解法一
单看题目，Floyd肯定是比较契合的，直接求出任意两点的最短路，然后枚举所有的点，但是时间复杂度不合适，所以考虑使用堆优化的Dijkstra，尝试以每个牧场作为源点，跑一遍最短路，然后求所有奶牛到该点的距离和，最终求一个最小的距离和，时间复杂度$O(NM\log N)$

```java
import java.util.*;
import java.io.*;

class Main {

    static int INF = 0x3f3f3f3f;
    static int N, P, C;
    static int[] cow;
    static int[] e, h, ne, w;
    static int idx;
    //a->b
    public static void add(int a, int b, int c) {
        w[idx] = c; e[idx] = b;
        ne[idx] = h[a]; h[a] = idx++;
    }

    public static void main(String... args) throws Exception {
        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int[] in = read(br);
        N = in[0]; P = in[1]; C = in[2];
        //边数: 2*C
        e = new int[C*2+1]; ne = new int[C*2+1]; w = new int[C*2+1];
        //点数: P
        h = new int[P+1]; Arrays.fill(h, -1);
        cow = new int[N+1]; // 奶牛所在牧场
        for (int i = 1; i <= N; i++) {
            cow[i] = read(br)[0];
        }
        for (int i = 0; i < C; i++) {
            int[] t = read(br);
            add(t[0], t[1], t[2]);
            add(t[1], t[0], t[2]);
        }
        int res = INF;
        for (int i = 1; i <= P; i++) {
            res = Math.min(dijkstra(i), res);
        }
        out.println(res);
        out.flush();
    }

    public static int dijkstra(int s) {
        int[] dis = new int[P+1];
        boolean[] vis = new boolean[P+1];
        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->dis[a]-dis[b]);
        Arrays.fill(dis, INF);
        dis[s] = 0; pq.add(s);
        while (!pq.isEmpty()) {
            int i = pq.poll();
            if (vis[i]) continue;
            vis[i] = true;
            for (int j = h[i]; j != -1; j = ne[j]) { //边编号
                int k = e[j]; //点编号
                if (w[j] == INF || dis[i] == INF) continue; 
                if (dis[k] > dis[i] + w[j]) {
                    dis[k] = dis[i] + w[j];
                    pq.add(k);
                }
            }
        }
        int sum = 0;
        for (int i = 1; i <= N; i++) {
            if (dis[cow[i]] == INF) return INF;
            sum += dis[cow[i]];
        }
        return sum;
    }

    public static int[] read(BufferedReader br) throws Exception {
        return Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
    }
}
```

## [1126. 最小花费](https://www.acwing.com/problem/content/1128/)

在$n$个人中，某些人的银行账号之间可以互相转账，这些人之间转账的手续费各不相同。

给定这些人之间转账时需要从转账金额里扣除百分之几的手续费，请问$A$最少需要多少钱使得转账后$B$收到$100$元。

**输入格式**

第一行输入两个正整数$n,m$，分别表示总人数和可以互相转账的人的对数。

以下$m$行每行输入三个正整数$x,y,z$，表示标号为$x$的人和标号为$y$的人之间互相转账需要扣除 $z\%$ 的手续费 ($z<100$)。

最后一行输入两个正整数 $A,B$。

数据保证$A$与$B$之间可以直接或间接地转账。

**输出格式**

输出$A$使得$B$到账$100$元最少需要的总费用。

精确到小数点后$8$位。

**数据范围**
- $1≤n≤2000$
- $m≤105$

**输入样例：**
```c
3 3
1 2 1
2 3 2
1 3 3
1 3
```
**输出样例：**
```c
103.07153164
```
### 解法一
这题让我对最短路的概念有了新的理解，前面的题目都是求权值和最小的路径，而这题中我们的边权值$w_i$是一个手续费的百分比数，我们设$A$转出的金额为$m$，根据题意可得$m(1-w_1)(1-w_2)...(1-w_k)=100$，我们希望$m$最小，也就是希望$(1-w_1)(1-w_2)...(1-w_k)$越大，那么这里就变成了一个求乘法最长路的问题

我们知道Dijkstra核心思想是：每次从未确定的最短路集合中选取最短的一个，从而确定该点的最短路，然后利用该点去松弛其他的点，然后重复该过程。而这题中边的权值$w_i$是一个小于$1$的小数（大于$0$），所以路径累乘是递减的，那么我们从**未确定的乘法最长路集合**中选取一个最大的点，它也就无法通过其他未确定的点中转来增大路径积，进而便可以确定该点的**乘法最长路**，符合Dijkstara的思想，所以该题可以直接使用Dijkstra。

```java
import java.util.*;
import java.io.*;

class Main {

    static int INF = 0x3f3f3f3f;
    static int N, M;
    static int idx;
    static int[] e, ne, h, w;
    //a->b 
    public static void add(int a, int b, int c){ 
        e[idx] = b; ne[idx] = h[a];
        w[idx] = c; h[a] = idx++;
    }

    public static void main(String... args) throws Exception {
        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream("./input.txt")));
        int[] in = read(br);
        int N = in[0], M = in[1];
        e = new int[2*M+1]; ne = new int[2*M+1]; w = new int[2*M+1];
        h = new int[N+1]; Arrays.fill(h, -1);
        for (int i = 0; i < M; i++) {
            int[] t = read(br);
            add(t[0], t[1], 100-t[2]);
            add(t[1], t[0], 100-t[2]);
        }
        int[] t = read(br);
        int A = t[0], B = t[1];
        double[] dis = new double[N+1];
        boolean[] vis = new boolean[N+1];
        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->(dis[b]>dis[a])?1:-1);
        dis[A] = 1.0; pq.add(A);
        while (!pq.isEmpty()) {
            int i = pq.poll();
            if (vis[i]) continue;
            vis[i] = true;
            for (int j = h[i]; j != -1; j = ne[j]) {
                int k = e[j];
                if (dis[k] < dis[i] * (w[j]/100.0)) {
                   dis[k] = dis[i] * (w[j]/100.0);
                   pq.add(k);
                }
            }
        }
        out.printf("%.8f", 100/dis[B]);
        out.flush();
    }

    public static int[] read(BufferedReader br) throws Exception {
        return Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
    }
}
```
> 进一步思考，如果权值都大于$1$，显然我们就只能通过Dijkstra求**乘法最短路**，那么如果权值既有大于1的也有小于1的（大于0）就只能用SPFA类似的算法了，并且SPFA既可以求最大值也能求最小值.