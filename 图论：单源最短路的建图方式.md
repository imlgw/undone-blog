---
title: 
   图论：单源最短路的建图方式
tags: 
  [算法,图论]
categories:
    [算法]
---
> 相关文章：[图论：常见的最短路算法模板](https://imlgw.top/2021/03/17/tu-lun-chang-jian-zui-duan-lu-suan-fa-mo-ban/)
## [1129. 热浪](https://www.acwing.com/problem/content/description/1131/)

德克萨斯纯朴的民众们这个夏天正在遭受巨大的热浪！！！

他们的德克萨斯长角牛吃起来不错，可是它们并不是很擅长生产富含奶油的乳制品，农夫John此时身先士卒地承担起向德克萨斯运送大量的营养冰凉的牛奶的重任，以减轻德克萨斯人忍受酷暑的痛苦。

John已经研究过可以把牛奶从威斯康星运送到德克萨斯州的路线。这些路线包括起始点和终点一共有$T$个城镇，为了方便标号为$1$到$T$。除了起点和终点外的每个城镇都由**双向道路**连向至少两个其它的城镇。每条道路有一个通过费用（包括油费，过路费等等）。

给定一个地图，包含$C$条直接连接2个城镇的道路。每条道路由道路的起点$R_s$，终点$R_e$和花费$C_i$组成。求从起始的城镇$T_s$到终点的城镇$T_e$最小的总费用。

**输入格式**

第一行: 4个由空格隔开的整数: $T,C,T_s,T_e$;

第 2 到第 $C+1$ 行: 第 $i+1$ 行描述第$i$条道路，包含3个由空格隔开的整数: $R_s,R_e,C_i$。

**输出格式**

一个单独的整数表示从$T_s$到$T_e$的最小总费用。数据保证至少存在一条道路。

**数据范围**
- $1≤T≤2500$
- $1≤C≤6200$
- $1≤Ts,Te,Rs,Re≤T$
- $1≤Ci≤1000$

**输入样例：**
```c
7 11 5 4
2 4 2
1 4 3
7 2 2
3 4 3
5 7 5
7 3 3
6 1 1
6 3 4
2 4 3
5 6 3
7 2 1
```
**输出样例：**
```c
7
```

### 解法一
很裸的题，正权图，数据范围不是很大，直接使用堆优化的`Dijkstra`
<details>

```java
import java.util.*;
import java.io.*;

class Main {

    public static void main(String... args) throws Exception {
        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream("./input.txt")));
        int[] in = read(br);
        int INF = 0x3f3f3f3f;
        int T = in[0], C = in[1], Ts = in[2], Te = in[3];
        int[][] w = new int[T+1][T+1];
        for (int i = 1; i <= T; i++) {
            Arrays.fill(w[i], INF);
        }
        for (int i = 0; i < C; i++) {
            int[] t = read(br);
            int x = t[0], y = t[1];
            w[x][y] = Math.min(w[x][y], t[2]);
            w[y][x] = Math.min(w[y][x], t[2]);
        }
        int[] dis = new int[T+1];
        Arrays.fill(dis, INF);
        dis[Ts] = 0;
        boolean[] vis = new boolean[T+1];
        PriorityQueue<Integer> queue = new PriorityQueue<>((a, b)->dis[a]-dis[b]);
        queue.add(Ts);
        while (!queue.isEmpty()) {
            int i = queue.poll();
            if (vis[i]) continue;
            vis[i] = true;
            for (int j = 1; j <= T; j++) {
                if (w[i][j] == INF) continue;
                if (dis[j] > dis[i] + w[i][j]) {
                    dis[j] = dis[i] + w[i][j];
                    queue.add(j);
                }
            }
        }
        out.println(dis[Te]);
        out.flush();
    }

    public static int[] read(BufferedReader br) throws Exception {
        return Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
    }
}
```
</details>

## [1128. 信使](https://www.acwing.com/problem/content/1130/)

战争时期，前线有$n$个哨所，每个哨所可能会与其他若干个哨所之间有通信联系。

信使负责在哨所之间传递信息，当然，这是要花费一定时间的（以天为单位）。
**指挥部设在第一个哨所**，当指挥部下达一个命令后，指挥部就派出若干个信使向与指挥部相连的哨所送信，当一个哨所接到信后，这个哨所内的信使们也以同样的方式向其他哨所送信。信在一个哨所内停留的时间可以忽略不计，直至所有 n 个哨所全部接到命令后，送信才算成功。

因为准备充足，每个哨所内都安排了足够的信使（如果一个哨所与其他 k 个哨所有通信联系的话，这个哨所内至少会配备 k 个信使）。

现在总指挥请你编一个程序，计算出完成整个送信过程最短需要多少时间。

**输入格式**

第$1$行有两个整数$n$和$m$，中间用$1$个空格隔开，分别表示有$n$个哨所和$m$条通信线路。

第$2$至$m+1$行：每行三个整数$i,j,k$，中间用$1$个空格隔开，表示第$i$个和第$j$个哨所之间存在 双向 通信线路，且这条线路要花费$k$天。

**输出格式**

一个整数，表示完成整个送信过程的最短时间，如果不是所有的哨所都能收到信，就输出-1。

**数据范围**
- $1≤n≤100$
- $1≤m≤200$
- $1≤k≤1000$

**输入样例：**
```c
4 4
1 2 4
2 3 7
2 4 1
3 4 6
```
**输出样例：**
```c
11
```

### 解法一
求至少需要多长时间其实就是求**最长的最短路**，数据范围很小，可以直接Floyd，我这里写了个SPFA
<details>

```java
import java.util.*;
import java.io.*;

class Main {

    public static void main(String... args) throws Exception {
        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int[] in = read(br);
        int INF = 0x3f3f3f3f;
        int N = in[0], M = in[1];
        int[][] w = new int[N+1][N+1];
        for (int i = 1; i <= N; i++) {
            Arrays.fill(w[i], INF);
        }
        for (int i = 0; i < M; i++) {
            int[] t = read(br);
            int x = t[0], y = t[1];
            w[x][y] = Math.min(w[x][y], t[2]);
            w[y][x] = Math.min(w[y][x], t[2]);
        }
        int[] dis = new int[N+1];
        boolean[] vis = new boolean[N+1];
        Arrays.fill(dis, INF);
        dis[1] = 0;
        Queue<Integer> queue = new LinkedList<>();
        queue.add(1); vis[1] = true;
        while (!queue.isEmpty()) {
            int i = queue.poll();
            vis[i] = false;
            for (int j = 1; j <= N; j++) {
                if (w[i][j]==INF) continue; //其实dis[i]不会为INF
                if (dis[j] > dis[i] + w[i][j]) {
                    dis[j] = dis[i] + w[i][j];
                    if (!vis[j]) {
                        queue.add(j);
                        vis[j] = true;
                    }
                }
            }
        }
        int res = 0;
        for (int i = 1; i <= N; i++) {
            res = Math.max(res, dis[i]);
        }
        out.println(res==INF ? -1 : res);
        out.flush();
    }

    public static int[] read(BufferedReader br) throws Exception {
        return Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
    }
}
```
</details>