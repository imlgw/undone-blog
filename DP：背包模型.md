---
title: 
   DP：背包模型
tags: 
  [算法]
categories:
    [算法]
---

## [423. 采药](https://www.acwing.com/problem/content/425/)

辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。

为此，他想拜附近最有威望的医师为师。

医师为了判断他的资质，给他出了一个难题。

医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”

如果你是辰辰，你能完成这个任务吗？

**输入格式**

输入文件的第一行有两个整数T和M，用一个空格隔开，T代表总共能够用来采药的时间，M代表山洞里的草药的数目。

接下来的M行每行包括两个在1到100之间（包括1和100）的整数，分别表示采摘某株草药的时间和这株草药的价值。

**输出格式**

输出文件包括一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。

**数据范围**

1≤T≤1000, 1≤M≤100

**输入样例：**
```c
70 3
71 100
69 1
1 2
```
**输出样例：**
```c
3
```

### 解法一

没啥好说的，裸的01背包，考虑每个物品装或者不装
```java
//裸01背包
public static int solve(int T, int M, int[] v, int[] cost) {
    //考虑前i件药，背包大小为j，能装的最大收益
    int[][] dp = new int[M+1][T+1];
    //dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])
    for (int i = 1; i <= M; i++) {
        for (int j = T; j >= 0; j--) {
            dp[i][j] = Math.max(dp[i-1][j], j >= cost[i-1] ? dp[i-1][j-cost[i-1]] + v[i-1] : -1);
        }
    }
    return dp[M][T];
}

//空间优化
public static int solveOpt(int T, int M, int[] v, int[] cost) {
    //考虑前i件药，背包大小为j，能装的最大收益
    //dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])
    int[] dp = new int[T+1];
    for (int i = 0; i < M; i++) {
        for (int j = T; j >= cost[i]; j--) {
            //j > cost[i] dp[j] = dp[j](old)
            dp[j] = Math.max(dp[j], dp[j-cost[i]] + v[i]);
        }
    }
    return dp[T];
}
```
[1024. 装箱问题](https://www.acwing.com/problem/content/1026/)和[278. 数字组合](https://www.acwing.com/problem/content/280/)和这个差不多，不多写了

## [1022. 宠物小精灵之收服](https://www.acwing.com/problem/content/1024/)

宠物小精灵是一部讲述小智和他的搭档皮卡丘一起冒险的故事。

一天，小智和皮卡丘来到了小精灵狩猎场，里面有很多珍贵的野生宠物小精灵。

小智也想收服其中的一些小精灵。

然而，野生的小精灵并不那么容易被收服。

对于每一个野生小精灵而言，小智可能需要使用很多个精灵球才能收服它，而在收服过程中，野生小精灵也会对皮卡丘造成一定的伤害（从而减少皮卡丘的体力）。

当皮卡丘的体力小于等于0时，小智就必须结束狩猎（因为他需要给皮卡丘疗伤），而使得皮卡丘体力小于等于0的野生小精灵也不会被小智收服。

当小智的精灵球用完时，狩猎也宣告结束。

我们假设小智遇到野生小精灵时有两个选择：收服它，或者离开它。

如果小智选择了收服，那么一定会扔出能够收服该小精灵的精灵球，而皮卡丘也一定会受到相应的伤害；如果选择离开它，那么小智不会损失精灵球，皮卡丘也不会损失体力。

小智的目标有两个：主要目标是收服尽可能多的野生小精灵；如果可以收服的小精灵数量一样，小智希望皮卡丘受到的伤害越小（剩余体力越大），因为他们还要继续冒险。

现在已知小智的精灵球数量和皮卡丘的初始体力，已知每一个小精灵需要的用于收服的精灵球数目和它在被收服过程中会对皮卡丘造成的伤害数目。

请问，小智该如何选择收服哪些小精灵以达到他的目标呢？

输入格式
输入数据的第一行包含三个整数：N，M，K，分别代表小智的精灵球数量、皮卡丘初始的体力值、野生小精灵的数量。

之后的K行，每一行代表一个野生小精灵，包括两个整数：收服该小精灵需要的精灵球的数量，以及收服过程中对皮卡丘造成的伤害。

输出格式
输出为一行，包含两个整数：C，R，分别表示最多收服C个小精灵，以及收服C个小精灵时皮卡丘的剩余体力值最多为R。

**数据范围**

0<N≤1000, 0<M≤500, 0<K≤100

**输入样例1：**
```c
10 100 5
7 10
2 40
2 50
1 20
4 20
```
**输出样例1：**
```c
3 30
```
**输入样例2：**
```c
10 100 5
8 110
12 10
20 10
5 200
1 110
```
**输出样例2：**
```c
0 100
```

### 解法一
`dp[i][j][k]`： 考虑前i个宠物，消耗j个精灵球和k点生命值，能捕获的最多的精灵数量，这里直接将一维消掉，就是个多维的01背包，时间复杂度`O(N*M*K)`大约5*10^7，已经在T的边缘了
```java
//多维01背包 O(N*M*K) 5 x 10^7
public static int[] solve(int N, int M, int K, int[] costN, int[] costM) {
    //dp[i][j]: 消耗最多i个精灵球和最多j点生命值，能捕捉的最多精灵数量
    int[][] dp = new int[N+1][M+1];
    for (int i = 0; i < K; i++) {
        for (int j = N; j >= costN[i]; j--) {
            for (int k = M; k >= costM[i]; k--) {
                //注意这里N和M的cost都满足才能计算
                dp[j][k] = Math.max(dp[j][k], dp[j-costN[i]][k-costM[i]] + 1);
            }
        }
    }
    int maxCnt = dp[N][M], minCost = 0;
    //枚举出捕获maxCnt个精灵球，消耗的最小生命值
    for (int i = 0; i <= M; i++) {
        if (dp[N][i] == maxCnt) {
            minCost = i;
            break;
        }
    }
    //最后+1，把之前的加回来
    return new int[]{maxCnt, M+1-minCost};
}
```

### 解法二

背包维度的转换，选择范围较小的作为状态值，设置`dp[i][j][k]`为：考虑前i个宠物，捕获j个精灵消耗k个精灵球，消耗的最少的生命值，这样时间复杂度就变成了`O(K*K*N)` 大概10^7，也是很大的一步优化了，当然也可以进一步优化成`O(K*K*M)`不过稍微难处理点，就不多写了

```java
//交换维度，降低复杂度，O(K^2*N) = 10^7 还可以优化成 k^2*m
public static int[] solveOpt(int N, int M, int K, int[] costN, int[] costM) {
    //dp[i][j]: 捕捉i个精灵，消耗j个精灵球，消耗的最少的体力值
    int[][] dp = new int[K+1][N+1];
    for (int i = 1; i <= K; i++) {
        for (int j = 0; j <= N; j++) {
            dp[i][j] = 0x3f3f3f3f; 
        }
    }
    for (int i = 0; i < K; i++) {
        for (int j = K; j >= 1; j--) {
            for (int k = N; k >= costN[i]; k--) {
                if (dp[j-1][k-costN[i]] + costM[i] <= M) {
                    dp[j][k] = Math.min(dp[j][k], dp[j-1][k-costN[i]]+costM[i]);
                }
            }
        }
    }
    int maxCnt = 0;
    for (int i = K; i >= 0; i--) {
        if (dp[i][N] <= M) {
            maxCnt = i;
            break;
        }
    }
    //最后+1，把之前的加回来
    return new int[]{maxCnt, M+1-dp[maxCnt][N]};
}
```

## [1023. 买书](https://www.acwing.com/problem/content/1025/)

小明手里有n元钱全部用来买书，书的价格为10元，20元，50元，100元。

问小明有多少种买书方案？（每种书可购买多本） 0 ≤ n ≤ 1000

### 解法一

完全背包，从头自己推了下递推公式，理解更深了一点
![](https://i.loli.net/2020/12/15/ljZW8eI4NkV6bCB.png)
```java
//完全背包
public static int solve(int N) {
    //dp[i][j]: 考虑前i本书，凑齐j价值的种类数
    int[][] dp = new int[5][N+1];
    //dp[i][j] = dp[i-1][j] + dp[i-1][j-c[i]] + dp[i-1][j-2*c[i]] + ... + dp[i-1][k*c[i]]
    //dp[i][j-c[i]] = dp[i-1][j-c[i]] + dp[i-1][j-2*c[i]] + ... + dp[i-1][k*c[i]]
    //dp[i][j] = dp[i-1][j] + dp[i][j-c[i]]
    dp[0][0] = 1;
    for (int i = 1; i <= 4; i++) {
        for (int j = 0; j <= N; j++) {
            dp[i][j] = dp[i-1][j];
            if (j >= price[i-1]) {
                dp[i][j] += dp[i][j-price[i-1]];
            }
        }
    }
    return dp[4][N];
}
```
降维
```java
//空间优化
public static int solveOpt(int N) {
    //dp[i][j]: 考虑前i本书，凑齐j价值的种类数
    int[] dp = new int[N+1];
    dp[0] = 1;
    for (int i = 1; i <= 4; i++) {
        for (int j = price[i-1]; j <= N; j++) {
            dp[j] += dp[j-price[i-1]];
        }
    }
    return dp[N];
}
```
[1021. 货币系统](https://www.acwing.com/problem/content/1023/)和这个一样，不多写

## [532. 货币系统（NOIP2018）](https://www.acwing.com/problem/content/534/)

在网友的国度中共有 n 种不同面额的货币，第 i 种货币的面额为 a[i]，你可以假设每一种货币都有无穷多张。

为了方便，我们把货币种数为 n、面额数组为 a[1..n] 的货币系统记作 (n,a)。 

在一个完善的货币系统中，每一个非负整数的金额 x 都应该可以被表示出，即对每一个非负整数 x，都存在 n 个非负整数 t[i] 满足 a[i]× t[i] 的和为 x。

然而，在网友的国度中，货币系统可能是不完善的，即可能存在金额 x 不能被该货币系统表示出。

例如在货币系统 n=3, a=[2,5,9] 中，金额 1,3 就无法被表示出来。 

两个货币系统 (n,a) 和 (m,b) 是等价的，当且仅当对于任意非负整数 x，它要么均可以被两个货币系统表出，要么不能被其中任何一个表出。 

现在网友们打算简化一下货币系统。

他们希望找到一个货币系统 (m,b)，满足 (m,b) 与原来的货币系统 (n,a) 等价，且 m 尽可能的小。

他们希望你来协助完成这个艰巨的任务：找到最小的 m。

**输入格式**

输入文件的第一行包含一个整数 T，表示数据的组数。

接下来按照如下格式分别给出T组数据。 

每组数据的第一行包含一个正整数 n。

接下来一行包含 n 个由空格隔开的正整数 a[i]。

**输出格式**

输出文件共有T行，对于每组数据，输出一行一个正整数，表示所有与 (n,a) 等价的货币系统 (m,b) 中，最小的 m。

**数据范围** : 1≤n≤100, 1≤a[i]≤25000, 1≤T≤20

**输入样例：**
```c
2 
4 
3 19 10 6 
5 
11 29 13 19 17 
```
**输出样例：**
```c
2
5
```

### 解法一
这里用了一个看起来很显然的结论：简化后的货币系统`(m,b)`，就是在原货币系统`(m,a)`中，剔除所有能被自分解的数得到的。判断集合中一个数能否被其他的数构成，其实问题就变成了完全背包求方案数，最后求得方案数为1的就是不能被分解的数，统计下结果就ok了
```java
public static int solve(int[] w) {
    int n = w.length;
    int max = 0;
    for (int i = 0; i < n; i++) {
        max = Math.max(max, w[i]);
    }
    int[] dp = new int[25001];
    dp[0] = 1;
    //完全背包求构成每个值的方案数
    for (int i = 0; i < n; i++) {
        for (int j = w[i]; j <= max; j++) {
            dp[j] += dp[j-w[i]];
        }
    }
    int res = 0;
    //方案数为1的就说明是不能丢掉的，统计一下就ok
    for (int i = 0; i < n; i++) {
        if (dp[w[i]] == 1) {
            res++;
        }
    }
    return res;
}
```

